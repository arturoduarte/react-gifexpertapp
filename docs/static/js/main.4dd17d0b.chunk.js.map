{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","evento","target","getGifs","category","a","url","encodeURI","fetch","respuesta","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","GifGrid","loading","state","setstate","useEffect","then","imgs","useFetchGifs","className","image","key","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"qMAIaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EAGZC,mBAAS,IAHG,mBAGzCC,EAHyC,KAG7BC,EAH6B,KAuBhD,OACE,0BAAMC,SAda,SAACC,GAEpBA,EAAEC,iBAGCJ,EAAWK,OAAOC,OAAS,IAE5BR,GAAc,SAAAS,GAAI,OAAKP,GAAL,mBAAoBO,OACtCN,EAAc,OAOd,2BACEO,KAAK,OACLC,MAAQT,EACRU,SAtBoB,SAACC,GACzBV,EAAcU,EAAOC,OAAOH,Y,uBCRnBI,EAAO,uCAAG,WAAMC,GAAN,uBAAAC,EAAA,6DAEfC,EAFe,iDAEiCC,UAAUH,GAF3C,+DAIGI,MAAMF,GAJT,cAIfG,EAJe,gBAMAA,EAAUC,OANV,uBAMdC,EANc,EAMdA,KAGDC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EAC3B,MAAO,CACLC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MAEXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAdjB,kBAmBdM,GAnBc,4CAAH,sDCAPO,EAAc,SAAC,GAAU,EAATL,KCGhBM,EAAU,SAAC,GAAkB,IAAhBhB,EAAe,EAAfA,SAAe,ECCb,SAAEA,GAAe,IAAD,EAEhBf,mBAAS,CACjCsB,KAAM,GACNU,SAAS,IAJ+B,mBAEnCC,EAFmC,KAE5BC,EAF4B,KAwB1C,OAfAC,qBAAU,WAGRrB,EAAQC,GACLqB,MAAK,SAAAC,GAEFH,EAAS,CACTZ,KAAMe,EACNL,SAAS,SAIf,CAACjB,IAGIkB,EDrBwBK,CAAavB,GAAhCa,EAJ2B,EAIhCN,KAAaU,EAJmB,EAInBA,QAEpB,OACE,oCACE,wBAAIO,UAAU,qCAAsCxB,GAEnDiB,GAAW,uBAAGO,UAAU,oCAAb,cAIZ,yBAAKA,UAAU,aAETX,EAAOJ,KAAK,SAAAgB,GAAK,OACf,kBAAC,EAAD,CACEC,IAAKD,EAAMd,GACXD,IAAMe,UErBTE,EAAe,WAAM,MAEI1C,mBAAS,CAAC,cAFd,mBAEzB2C,EAFyB,KAEb5C,EAFa,KAchC,OACE,oCACE,4CAEA,kBAAC,EAAD,CAAaA,cAAgBA,IAC7B,6BAGA,4BAGI4C,EAAWnB,KAAK,SAAAT,GAAQ,OACtB,kBAAC,EAAD,CACE0B,IAAO1B,EACPA,SAAaA,U,MCzB3B6B,IAASC,OACL,kBAAC,EAAD,MACFC,SAASC,eAAe,U","file":"static/js/main.4dd17d0b.chunk.js","sourcesContent":["import React, { useState } from 'react'\nimport PropTypes from 'prop-types'\n\n                              // desestructuración de (props.setCategories)\nexport const AddCategory = ({ setCategories }) => {\n\n  // estado del input\n  const [inputValue, setInputValue] = useState('');\n\n  // reasignamos el valor del input a inputValue\n  const handleInputChange = (evento) => {\n    setInputValue(evento.target.value);\n  }\n\n  const handleSubmit = (e) => {\n    // para prevenir el submit\n    e.preventDefault();\n    \n    // validación para no permitir campos vacios\n    if(inputValue.trim().length > 2){\n      // el primer argumento es el valor del estado anterior, y luego regresa en nuevo estado\n      setCategories(cats => [inputValue, ...cats])        \n      setInputValue('');\n    }\n\n  }\n\n  return (    \n    <form onSubmit={handleSubmit}>\n      <input \n        type=\"text\" \n        value= {inputValue}       \n        onChange = {handleInputChange}\n      />\n    </form>    \n  )  \n}\n\nAddCategory.propTypes = {\n  setCategories: PropTypes.func.isRequired\n}    \n","// Es llamado desde GifGrid\n\n// al ser async retorna una promesa\nexport const getGifs = async(category) => {\n  // para escapar espacios --> encodeUri\n  const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=hsqe4aOpAdWN2nzb4d1ZzLEVxsQUci5B`\n\n  const respuesta = await fetch(url)\n  // desestructuración de la data\n  const {data} = await respuesta.json();\n  // console.log(data);\n\n  const gifs = data.map(img => {\n    return {\n      id: img.id,\n      title: img.title,\n      // ? --> si viene la información que lo utilice\n      url: img.images?.downsized_medium.url\n    }\n  })\n\n\n  return gifs;\n\n  // console.log(gifs);\n  // almacenamos los valores en setImages\n  // setImages(gifs)        \n}","import React from 'react'\n\n\nexport const GifGridItem = ({img}) => {\n    \n  return (\n    // las clases animates fueron importadas desde https://animate.style/\n    <div className=\"card animate__animated animate__fadeIn\">\n      <img src={img.url} alt={img.title} />\n      <p>{img.title}</p>\n    </div>\n  )\n}\n","import React from 'react'\nimport { useFetchGifs } from '../hooks/useFetchGifs'\nimport { GifGridItem } from './GifGridItem';\n\n\n\nexport const GifGrid = ({ category }) => {\n  \n  // desestructuración(dos puntos es para renombrar la variable)\n  // useFetchGifs --> es un customHooks\n  const {data:images, loading} = useFetchGifs(category);\n      \n  return (\n    <>\n      <h3 className=\"animate__animated animate__fadeIn\">{ category }</h3>\n      \n      {loading && <p className=\"animate__animated animate__flash\">loading...</p>}\n      \n        {/* iteramos cada valor del hash */}\n\n      <div className=\"card-grid\">        \n          {\n            images.map( image => (            \n              <GifGridItem \n                key={image.id} \n                img= {image} \n              />\n            ))\n        }\n        \n      </div>\n    </>\n  )\n}\n\n","// los customHooks, es una forma de extraer lógica de algún componente, o lógica que queremos reutilizar y extraerla de tal manera que sea sencillo utilizarla nuevamente\n// Los hooks son funciones\n// los hooks también pueden tener un estado\n\nimport { useState, useEffect } from \"react\"\nimport { getGifs } from '../helpers/getGifs';\n\nexport const useFetchGifs = ( category ) => {\n\n  const [state, setstate] = useState({\n    data: [],\n    loading: true\n  })\n\n  \n  // ejecutar cierto código de forma condicional, solo se dispara cuando cambia la vategoría\n  useEffect(()=>{\n    // lo que hace es ejecutar la instrucción cuando el componente es renderizado por primera vez\n    // retorna una promesa, porque el método es un async, por eso escribimos el then    \n    getGifs(category)\n      .then(imgs => {\n                                      \n          setstate({\n          data: imgs,\n          loading: false\n        })\n        \n    });\n  },[category])\n    \n\n  return state; //{data: [], loading: true}\n}","import React, { useState } from 'react';\nimport { AddCategory } from './components/AddCategory';\nimport { GifGrid } from './components/GifGrid';\n\nexport const GifExpertApp = () => {  \n  // hook \n  const [categories, setCategories] = useState(['One Punch']);\n\n  // const handleAdd = (e) => {    \n  //   // ****Primera solución*****\n  //   // extraemos las categorias con el operador spread, y añadimos una nueva\n  //   // setCategories([...categories, 'Hunter'])\n\n  //   // *****2da Solución*****\n  //   // el primer argumento es el valor del estado anterior, y luego regresa en nuevo estado\n  //   setCategories(cats => [...cats, 'Hunter'])    \n  // }\n\n  return (\n    <>    \n      <h2>GifExpertApp</h2>\n      {/* le mandamos propiedades al AddCategory, en este caso una función */}\n      <AddCategory setCategories={ setCategories } />\n      <hr />\n\n      \n      <ol>\n          {/* el map recibe 2 argumentos por defecto, el primero es el elemento del arreglo, y luego tenemos el indice*/}\n        {\n          categories.map( category => (\n            <GifGrid \n              key = {category}\n              category = { category }\n            />\n          ))\n        }\n      </ol>\n    </>\n    \n    );\n  }  \n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport {GifExpertApp} from './GifExpertApp'\nimport './index.css';\n\n\nReactDOM.render(  \n    <GifExpertApp />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}